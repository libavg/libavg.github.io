<!DOCTYPE html>
<!--[if IE 6]>
<html id="ie6" lang="en-US" prefix="og: http://ogp.me/ns#">
<![endif]-->
<!--[if IE 7]>
<html id="ie7" lang="en-US" prefix="og: http://ogp.me/ns#">
<![endif]-->
<!--[if IE 8]>
<html id="ie8" lang="en-US" prefix="og: http://ogp.me/ns#">
<![endif]-->
<!--[if !(IE 6) | !(IE 7) | !(IE 8)  ]><!-->
<html lang="en-US" prefix="og: http://ogp.me/ns#">
<!--<![endif]-->

<!-- Mirrored from www.libavg.de/blog/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 11 Jan 2025 18:15:15 GMT -->
<!-- Added by HTTrack -->
<meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
<!-- /Added by HTTrack -->
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width"/>
    <title>libavg | Media and Interaction Development</title>
    <link rel="profile" href="http://gmpg.org/xfn/11"/>
    <link rel="stylesheet" type="text/css" media="all"
          href="wp-content/themes/twentyeleven-child/style.css"/>
    <link rel="pingback" href="xmlrpc.php"/>
    <!--[if lt IE 9]>
    <script src="wp-content/themes/twentyeleven/js/html5.js"
            type="text/javascript"></script>
    <![endif]-->

    <!-- This site is optimized with the Yoast WordPress SEO plugin v1.3.1.1 - http://yoast.com/wordpress/seo/ -->
    <link rel="canonical" href="index.html"/>
    <meta property='og:locale' content='en_US'/>
    <meta property='og:title'
          content='libavg | Media and Interaction Development'/>
    <meta property='og:url' content='index.html'/>
    <meta property='og:site_name' content='libavg'/>
    <meta property='og:type' content='website'/>
    <!-- / Yoast WordPress SEO plugin. -->

    <meta name="generator" content="WordPress 3.6.1"/>
    <style>
        /* Link color */
        a,
        #site-title a:focus,
        #site-title a:hover,
        #site-title a:active,
        .entry-title a:hover,
        .entry-title a:focus,
        .entry-title a:active,
        .widget_twentyeleven_ephemera .comments-link a:hover,
        section.recent-posts .other-recent-posts a[rel="bookmark"]:hover,
        section.recent-posts .other-recent-posts .comments-link a:hover,
        .format-image footer.entry-meta a:hover,
        #site-generator a:hover {
            color: #1e7d0a;
        }

        section.recent-posts .other-recent-posts .comments-link a:hover {
            border-color: #1e7d0a;
        }

        article.feature-image.small .entry-summary p a:hover,
        .entry-header .comments-link a:hover,
        .entry-header .comments-link a:focus,
        .entry-header .comments-link a:active,
        .feature-slider a.active {
            background-color: #1e7d0a;
        }
    </style>

</head>

<body class="home blog single-author two-column right-sidebar">
<div id="page" class="hfeed">
    <header id="branding" role="banner">
        <hgroup>
            <h1 id="site-title"><span><a href="index.html" title="libavg"
                                         rel="home">libavg</a></span></h1>
            <h2 id="site-description" style="margin-bottom:30px">Media and
                Interaction Development</h2>
        </hgroup>

        <a href="index.html">
            <img src="img/cropped-cropped-radarstation-2.jpg"
                 width="1000" height="150" alt=""/>
        </a>

        <nav id="access" role="navigation">
            <h3 class="assistive-text">Main menu</h3>
            <div class="skip-link"><a class="assistive-text" href="#content"
                                      title="Skip to primary content">Skip to
                primary content</a></div>
            <div class="skip-link"><a class="assistive-text" href="#secondary"
                                      title="Skip to secondary content">Skip to
                secondary content</a></div>
            <div class="menu">
                <ul>
                    <li class="current_page_item"><a href="index.html"
                                                     title="Home">Home</a></li>
                    <li class="page_item page-item-2"><a
                            href="about.html">About</a></li>
                </ul>
            </div>
        </nav><!-- #access -->
    </header><!-- #branding -->


    <div id="main">

        <div id="primary">
            <div id="content" role="main">

                <article id="post-162"
                         class="post-162 post type-post status-publish format-standard hentry category-uncategorized">
                    <header class="entry-header">
                        <h1 class="entry-title">Colors</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2015-05-29T00:06:18+00:00">May 29,
                                2015
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>libavg has always supported specifying colors in
                            html-like fashion: You pass a string of six hex
                            digits, two each for the red, green and blue
                            components of the color. That&#8217;s nice if you&#8217;re
                            copying the code from Gimp or Photoshop, but it was
                            quite limiting if you wanted to actually calculate
                            colors or maybe interpolate between two colors.</p>
                        <p>So&#8230; there&#8217;s a shiny new <a
                                href="/reference/dev/misc.html?highlight=color#libavg.avg.Color"
                                target="_blank"><code>Color</code></a> class
                            that can be constructed from a tuple and passed
                            whereever color strings were expected before (of
                            course, strings still work). Colors can be mixed and
                            used in animations. Last but not least, I did some
                            research on smart ways to mix colors. It turns out
                            that a simple weighed average of the RGB components
                            doesn&#8217;t look so good &#8211; for instance,
                            mixing 50% red with 50% yellow results gives you
                            gray. So libavg now mixes in CIE L&#8217;ch color
                            space, which more-or-less preserves the saturation
                            and looks pretty good. </p>
                        <p>As a result, you can now do this:</p>
                        <pre><code><span style="font-size: 10px">startColor = avg.Color("0000FF")
endColor = avg.Color("FFFF00")
for i in xrange(11):
    color = avg.Color.mix(startColor, endColor, 1-(i/10.))
    avg.RectNode(pos=(i*20,0), size=(20,20), fillcolor=color, 
            fillopacity=1.0, parent=rootNode)
</span></code></pre>
                        <p>to produce:
                        <center><img src="img/colors.jpg"
                                     alt="colors" width="221" height="22"
                                     class="alignnone size-full wp-image-168"/>
                        </center>
                        </p>
                        <p>More infos on color mixing are in <a
                                href="https://coderwall.com/p/_w1rra/using-cie-lch-for-better-color-blending"
                                target="_blank">this blog post</a>.</p>
                    </div><!-- .entry-content -->
                </article><!-- #post-162 -->


                <article id="post-155"
                         class="post-155 post type-post status-publish format-standard hentry category-raspberry-pi">
                    <header class="entry-header">
                        <h1 class="entry-title">Raspberry Pi Update</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2015-04-25T20:21:12+00:00">April 25,
                                2015
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>libavg has supported the Raspberry Pi for <a
                                href="raspberry-pi-support/index.html"
                                title="Raspberry Pi Support">a while</a> now. In
                            the last few weeks, I set up a cross-compile
                            toolchain: You compile libavg for the Raspberry Pi
                            on a separate Linux machine. This means compiling is
                            done in a few minutes (as opposed to an hour or more
                            if you compile directly) &#8211; here are <a
                                    href="../site/projects/libavg/wiki/RaspberryPISourceInstall.html"
                                    title="build instructions" target="_blank">build
                                instructions</a>. Also, after a <a
                                    href="https://github.com/libavg/libavg/issues/631"
                                    title="bugfix" target="_blank">bugfix</a>,
                            we have full libavg functionality on the Pi. Video
                            decoding, sadly, is still done in software, since
                            the first two people that have tried implementing it
                            have given up &#8211; I&#8217;ll see what I can do
                            on that front.</p>
                    </div><!-- .entry-content -->
                </article><!-- #post-155 -->


                <article id="post-149"
                         class="post-149 post type-post status-publish format-standard hentry category-optimization category-rendering">
                    <header class="entry-header">
                        <h1 class="entry-title">Speed</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2015-01-28T23:07:01+00:00">January
                                28, 2015
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>libavg just got another major optimization. </p>
                        <p>I implemented an image registry and cache for libavg.
                            <code>ImageNode</code>s that reference the same
                            image file now reference the same bitmap in CPU
                            memory and the same texture in GPU memory. This is
                            completely hidden from the app developer, who just
                            specifies the file location for all instances. The
                            obvious benefit is that this saves a lot of memory
                            if an application re-uses lots of bitmaps. The less
                            obvious benefit is that it speeds things up as well:
                            <code>avg_checkspeed</code>, which tests with
                            thousands of identical <code>ImageNode</code>s, can
                            now handle around 15000 Nodes at 60 FPS on my old i7
                            (still Core i7 920 Bloomfield, 2.66 MHz, NVidia
                            GF260 like in the old <a
                                    href="speedinguprendering/index.html"
                                    title="Benchmarks">benchmarks</a>). This is
                            twice as many as before.</p>
                    </div><!-- .entry-content -->

                </article><!-- #post-149 -->


                <article id="post-146"
                         class="post-146 post type-post status-publish format-standard hentry category-documentation">
                    <header class="entry-header">
                        <h1 class="entry-title">A Tutorial</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2014-12-02T01:12:14+00:00">December
                                2, 2014
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>Finally, libavg has a tutorial. Over the last few
                            weekends, I&#8217;ve put together a short but
                            thorough tutorial on libavg. It covers the important
                            concepts &#8211; app structure, scene graph, update
                            loop, event handling and deriving your own node
                            classes &#8211; and it does this in the context of a
                            short and very nice 500-line program that exercises
                            all of these concepts.</p>
                        <p>The firebirds sample that&#8217;s been included in
                            libavg for a while is the basis for this tutorial.
                            In fact, when Scotty wrote the sample two or three
                            years ago, I promised him that I&#8217;d write a
                            tutorial based on it &#8211; Scotty, thanks for the
                            sample and sorry for taking so long!</p>
                    </div><!-- .entry-content -->

                </article><!-- #post-146 -->


                <article id="post-142"
                         class="post-142 post type-post status-publish format-standard hentry category-optimization category-rendering">
                    <header class="entry-header">
                        <h1 class="entry-title">Multithreading, Realtime Graphics
                            and Process Affinity Masks</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2014-10-11T19:43:29+00:00">October
                                11, 2014
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>In libavg, we try to make it as easy as possible to
                            have a consistent framerate that matches the screen
                            refresh rate. For almost all current systems (and
                            ignoring new developments such as NVidia G-Sync),
                            that means delivering a new frame every 16.67
                            milliseconds.</p>
                        <p>To make this possible, libavg is designed as a
                            multi-threaded system and long-running tasks are
                            moved to separate threads. So, for instance, the
                            <code>BitmapManager</code> class loads image files
                            in one or more background threads (the number of
                            background threads is configurable using <code>BitmapManager.setNumThreads()</code>),
                            the <code>VideoWriter</code> uses a background
                            thread to encode and write video files, and all
                            videos are decoded in background threads as well.
                            Besides enabling quick screen updates in the main
                            thread, this also allows libavg-based programs to
                            utilize more than one core in a multi-core computer.
                            The threads are distributed among the cores by the
                            operating system according to the load, and in
                            general, this works pretty well. </p>
                        <p>However, the operating system has no way of knowing
                            that one of the libavg threads is special and should
                            be able to churn out frames at 60 fps. So, if the
                            background threads cause too much load, some of them
                            will run on the same core that the main thread is
                            running on, and framerate can become irregular.</p>
                        <p>Happily, there&#8217;s a cure for the issue: We lock
                            the screen update thread to one specific core and
                            forbid all other threads from using this core using
                            thread affinity functions.</p>
                    </div><!-- .entry-content -->

                </article><!-- #post-142 -->


                <article id="post-139"
                         class="post-139 post type-post status-publish format-standard hentry category-uncategorized">
                    <header class="entry-header">
                        <h1 class="entry-title">Version 1.8.2 Released</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2014-07-16T23:36:52+00:00">July 16,
                                2014
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>Release 1.8.1 broke audio on some linux machines and
                            all macs, so we&#8217;ve <a
                                    href="https://github.com/libavg/libavg/releases"
                                    target="_blank">released version 1.8.2</a>
                            that just fixes this bug.</p>
                    </div><!-- .entry-content -->

                </article><!-- #post-139 -->


                <article id="post-134"
                         class="post-134 post type-post status-publish format-standard hentry category-website">
                    <header class="entry-header">
                        <h1 class="entry-title">Switch to
                            github &#038; Version 1.8.1 Released</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2014-06-21T23:55:26+00:00">June 21,
                                2014
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>We&#8217;ve moved the libavg sourcecode from our own
                            svn repository to github. Here&#8217;s the project
                            in it&#8217;s full glory:
                            https://github.com/libavg/libavg. Obviously, that
                            gives us the full power of github, including much
                            better issue and branch/merge tracking, easy
                            forking, etc.. If you look at the libavg network
                            graph, you can see that we&#8217;re busy using all
                            these new capabilities <img
                                    src='img/icon_smile.gif'
                                    alt=':-)' class='wp-smiley'/> .</p>
                        <p>Most of the work needed &#8211; including moving all
                            branches, issue tracking, adapting the continuous
                            build, fixing web links and instructions etc.
                            &#8211; was done by <a
                                    href="https://github.com/klemmster"
                                    target="_blank">Richy</a>, with help by <a
                                    href="https://github.com/oxullo"
                                    target="_blank">OXullo</a> and <a
                                    href="https://github.com/BenediktSeidl"
                                    target="_blank">Benedikt Seidl</a>. Thanks!
                        </p>
                        <p>Also, we just <a
                                href="https://github.com/libavg/libavg/releases"
                                target="_blank">released version 1.8.1</a>, a
                            bugfix release. Of course, we happily used github
                            support for this.</p>
                    </div><!-- .entry-content -->

                </article><!-- #post-134 -->


                <article id="post-122"
                         class="post-122 post type-post status-publish format-standard hentry category-optimization category-rendering">
                    <header class="entry-header">
                        <h1 class="entry-title">Supporting Twelve Screens at
                            Once</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2014-03-05T22:55:44+00:00">March 5,
                                2014
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>Our latest and biggest (not to mention coolest) toy
                            at the <a href="http://imld.de/" target="_blank">Interactive
                                Media Lab Dresden</a> is a ten square-meter <a
                                    href="http://www.imld.de/en/news/2013/09/the-interactive-display-wall-arrived/"
                                    target="_blank">interactive wall</a> that&#8217;s
                            fully touch-sensitive and supports markers and pens
                            as well. It consists of twelve Full HD monitors
                            hooked up to two Radeon 7970 graphics cards in a
                            single dual-Xeon workstation. Since it&#8217;s
                            driven by a single workstation, we can drive the
                            complete wall with a single application, which is
                            really cool and sets it apart from most similar
                            setups. However, the dual-graphics-card setup causes
                            issues: Under Linux, we have two separate desktops,
                            and under Windows, applications that span the
                            graphics card boundary are extremely slow.</p>
                        <p>To get full-screen rendering at interactive speeds,
                            you basically have to open two borderless windows
                            &#8211; each spanning 6 screens and pinned to one of
                            the GPUs. Then you render the same scene with
                            different viewports in each of the windows. That
                            means that all context-specific data &#8211;
                            textures, vertex buffers, shaders, framebuffer
                            objects, and even caching of shader parameters
                            &#8211; needs to be replicated across both contexts.
                            Also, we can&#8217;t switch contexts too often,
                            because that would make things slow.</p>
                        <p>libavg renders in two passes: The first (implemented
                            in the <code>Node.preRender()</code> functions)
                            prepares textures and vertex data. It also renders
                            FX nodes. The second pass (implemented in <code>Node.render()</code>)
                            actually sends render commands to the graphics card.
                            The multi-context code changes a few things: While
                            <code>preRender()</code> is still executed only
                            once, render() is executed once per GPU. Uploads of
                            data as well as effects that need to be rendered are
                            scheduled in preRender and actually executed at the
                            beginning of the render. In total, refactoring
                            everything accordingly was (obviously) a lot of work
                            that impacts lots of code all over the graphics
                            engine, but the result is good rendering performance
                            with 24 megapixels of resolution.</p>
                        <p>The code is still on a branch (The svn repository is
                            at
                            https://www.libavg.de/svn/branches/experiments/libavg_multicontext/),
                            but it passes all tests, and I&#8217;ll merge it to
                            trunk after we&#8217;ve used it a bit.</p>
                    </div><!-- .entry-content -->

                </article><!-- #post-122 -->


                <article id="post-117"
                         class="post-117 post type-post status-publish format-standard hentry category-uncategorized">
                    <header class="entry-header">
                        <h1 class="entry-title">Version 1.8 Released</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2014-02-15T18:12:18+00:00">February
                                15, 2014
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>I&#8217;ve just released version 1.8 of libavg. You
                            can download it at the <a
                                    href="../site/projects/libavg/wiki/DownLoad.html">usual
                                place</a>.</p>
                        <p>This means that finally, all of the cool features
                            that have been in the development version for a
                            while are available in an easy-to-install package.
                            The release includes a skinnable widget library, a
                            unified event handling framework (see <a
                                    title="Cleaning up Messaging"
                                    href="cleaning-up-messaging/index.html">Cleaning
                                up Messaging</a>), and a much-improved App class
                            by OXullo. Scotty added a very nice sample program
                            called firebirds that showcases libavg development
                            in a compact form, and Richy implemented a new
                            logging framework. Rendering is <em>much</em> faster
                            (see <a title="Speeding up Rendering"
                                    href="speedinguprendering/index.html">Speeding
                                up Rendering</a>), and I completely rewrote the
                            video decoding subsystem (see <a
                                    title="Video Decoding using libav and ffmpeg"
                                    href="libavffmpeg-video-decoding/index.html">Video
                                Decoding using libav and ffmpeg</a>). Lots of
                            other things have been improved as well &#8211; see
                            the <a href="../site/login8594.html">NEWS file</a>
                            for details.</p>
                        <p>Lots of thanks to OXullo, Richy and Scotty for
                            testing the release!</p>
                    </div><!-- .entry-content -->

                </article><!-- #post-117 -->


                <article id="post-81"
                         class="post-81 post type-post status-publish format-standard hentry category-video-decoding">
                    <header class="entry-header">
                        <h1 class="entry-title">Video Decoding using libav and
                            ffmpeg</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2013-02-12T02:05:17+00:00">February
                                12, 2013
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>I spent the last month completely taking the libavg
                            video decoding module apart and putting it together
                            again. I&#8217;m finally convinced that the code is
                            well-designed and readable &#8211; and it&#8217;s
                            fast. It turns out that getting good video decoding
                            is not as easy as it sounds, so I&#8217;ve written
                            up a complete description of the insides for anyone
                            that&#8217;s interested: <a
                                    href="../site/projects/libavg/wiki/VideoDecoding.html"
                                    target="_blank">VideoDecoding</a>.</p>
                        <p>The weird thing is that from the outside, it looks
                            like a solved problem, so every time I start telling
                            someone about this, I get the same reaction. There&#8217;s
                            libraries for that, right? You just plug in <a
                                    href="https://libav.org/" target="_blank">libav</a>
                            or <a href="https://ffmpeg.org/" target="_blank">ffmpeg</a>
                            or <a href="http://gstreamer.freedesktop.org/"
                                  target="_blank">gstreamer</a> or proprietary
                            things like <a
                                    href="https://developer.apple.com/quicktime/"
                                    target="_blank">QuickTime</a> or <a
                                    href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd375454(v=vs.85).aspx"
                                    target="_blank">DirectShow</a>. All these
                            libraries have existed for years, so they&#8217;re
                            stable and easy to use, right?</p>
                        <p>Well, yes and no. If you don&#8217;t need advanced
                            features, high-level libraries like gstreamer might
                            do what you want. But we want frame-accurate seeking
                            and a low-latency mode, as well as color space
                            conversion using shaders. Opening and closing video
                            files shouldn&#8217;t cause any interface stutters,
                            and so on. Also, libavg can&#8217;t work with
                            proprietary libs &#8211; we need something that
                            works cross-plattform. That leaves libav/ffmpeg, and
                            this library exposes a pretty low-level interface.
                            It does support every codec but the kitchen sink
                            (pardon the wording) and gives you control over
                            every knob that all of these codecs have to tune
                            things. That&#8217;s really great, because you
                            wanted control, right? Anyway, you can get
                            everything done with libav/ffmpeg, but suddenly
                            things get complicated. For starters, you&#8217;re
                            suddenly juggling five threads: demuxer, video
                            decoder, audio decoder, display and audio mixer.
                            libav/ffmpeg leaves all the threading to the user,
                            so you&#8217;re dealing with a pretty complicated
                            real-time system where lots of things happen at the
                            same time. Dranger&#8217;s <a
                                    href="http://dranger.com/ffmpeg/"
                                    target="_blank">tutorial</a> helps, but it&#8217;s
                            dated. </p>
                        <p>To make things worse, the interface of libav/ffmpeg
                            changes with minor revision numbers, so to support a
                            few years of operating systems, you find yourself
                            adding a generous amount of <code>#ifdefs</code> to
                            the code. I couldn&#8217;t find documentation that
                            describes which changes happened in which minor
                            revision, so you need to guess appropriate version
                            numbers for the <code>#ifdefs</code> based on tests
                            with multiple systems. Oh, and there&#8217;s
                            actually several constituent libraries that each
                            have their own version number. Of course, you need
                            to query the correct one. All of that takes time;
                            the resulting code is hard to read and test. In
                            addition, since ffmpeg forked and the developers
                            aren&#8217;t on speaking terms (see <a
                                    href="http://blog.pkh.me/p/13-the-ffmpeg-libav-situation.html"
                                    target="_blank">this</a> and <a
                                    href="https://lists.ubuntu.com/archives/technical-board/2011-May/000891.html"
                                    target="_blank">this</a> if you really want
                            to know more), you need to test with libav (the
                            fork) and ffmpeg (the original) if you want maximum
                            compatibility.</p>
                        <p>All of this is really a pity, because I think the
                            libav/ffmpeg developers are insanely smart guys and
                            the library does do a really admirable job of de-
                            and encoding everything you can throw at it. Also,
                            if I&#8217;m honest, most of the time spent was
                            figuring out how to organize the different threads
                            well &#8211; and that&#8217;s something I really can&#8217;t
                            blame libav/ffmpeg for.</p>
                        <p>Anyway, we&#8217;re now ready to add Raspberry Pi
                            (read: OpenMAX IL) and VA-API hardware decoding,
                            seamless audio loops and other cool things to
                            libavg.</p>
                    </div><!-- .entry-content -->

                </article><!-- #post-81 -->

                <article id="post-62"
                         class="post-62 post type-post status-publish format-standard hentry category-raspberry-pi category-rendering category-video-decoding">
                    <header class="entry-header">
                        <h1 class="entry-title">Raspberry Pi Support</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2012-11-25T22:42:42+00:00">November
                                25, 2012
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="../../author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>I&#8217;m sure most of you have heard of the <a
                                href="http://www.raspberrypi.org/"
                                target="_blank">Raspberry Pi</a>, a $25 ARM
                            computer that runs Linux. We&#8217;ve spent quite a
                            bit of time in the last weeks getting libavg to run
                            on this machine, and I&#8217;m happy to say that we
                            have a working beta. We render to a
                            hardware-accelerated OpenGL ES surface and almost
                            all tests succeed. Besides full image, text and
                            software video support, that includes all
                            compositing and even offscreen rendering and general
                            support for shader-based FX.
                            <del datetime="2015-05-28T21:20:53+00:00">We have
                                brief setup instructions at <a
                                        href="../../../site/projects/libavg/wiki/RPI.html"
                                        target="_blank">https://www.libavg.de/site/projects/libavg/wiki/RPI</a>.
                            </del>
                            <em>Update: The setup instructions have been updated
                                for cross-compiling (much faster!) and moved to
                                <a href="../../../site/projects/libavg/wiki/RaspberryPISourceInstall.html"
                                   target="_blank">https://www.libavg.de/site/projects/libavg/wiki/RaspberryPISourceInstall</a></em>.
                        </p>
                        <p>Most of the work was getting libavg to work with
                            OpenGL ES. We now decide whether to use desktop or
                            mobile OpenGL depending on a configure switch, an
                            <code>avgrc</code> entry and the hardware
                            capabilities. Along the way, we implemented mobile
                            context support under Linux for NVidia and Intel
                            graphics systems, so we can now test most things
                            without actually running (and compiling!) things on
                            the Raspberry. Speaking of which &#8211; compiling
                            for the Raspberry takes a long time. Compiling <em>on</em>
                            it is impossible because there just isn&#8217;t
                            enough memory. We currently chroot into a Raspberry
                            file system and compile there (see the notes linked
                            above). </p>
                        <p>A lot of things are already implemented the way they
                            should be for a mobile system. That means that, for
                            example, bitmaps are loaded (and generated, and read
                            back from texture memory&#8230;) in either RGB or
                            BGR pixel formats depending on the flavor of OpenGL
                            used and the vertex arrays are smaller now so we
                            save bandwidth. Still, there&#8217;s a lot of
                            optimization to do. Our next step is getting things
                            stable and fast. We want hardware video decoding,
                            compressed textures &#8211; and in general, we&#8217;ll
                            be profiling to find spots that take more time than
                            they should.</p>
                    </div><!-- .entry-content -->

                </article><!-- #post-62 -->


                <article id="post-43"
                         class="post-43 post type-post status-publish format-standard hentry category-input">
                    <header class="entry-header">
                        <h1 class="entry-title">Cleaning up Messaging</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2012-09-29T14:22:25+00:00">September
                                29, 2012
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="../../author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>Over time, libavg has accumulated support for a
                            number of message callbacks. These are:</p>
                        <ul>
                            <li>Low-level input events such as mouse clicks,
                                touches and key presses, using <a
                                        href="/reference/svn/basenodes.html#libavg.avg.Node.connectEventHandler"><code>Node::connectEventHandler()</code></a>
                                and kin,
                            </li>
                            <li>Touch <a
                                    href="/reference/svn/events.html#libavg.avg.Contact"><code>Contact</code></a>
                                handling,
                            </li>
                            <li><a href="/reference/svn/ui.html">Gesture
                                recognizer</a> callbacks and
                            </li>
                            <li>Video and audio <a type="_moz">end of file
                                notifications.</a></li>
                        </ul>
                        <p>In addition, we&#8217;re currently adding some widget
                            classes, and that adds more callbacks for button
                            presses, list scrolling, etc.</p>
                        <p>While this allows you to get a lot of things done, it&#8217;s
                            not consistent and hence not very easy to learn. The
                            methods used to register for messages aren&#8217;t
                            standardized. They have inconsistent names and
                            varying parameters. Some allow you to register
                            several callbacks for an event, some don&#8217;t.
                            For an example, compare <a
                                    href="/reference/svn/basenodes.html#libavg.avg.Node.connectEventHandler"><code>Node.connectEventHandler()</code></a>
                            to the gesture interface using constructor
                            parameters. In addition, the implementation is just
                            as problematic. We have multiple callback
                            implementations in C++ and Python, which results in
                            error-prone, high-maintanance code.</p>
                        <h1>Publishers</h1>
                        <p>When work on the new widget classes promised to make
                            things even more convulted, we decided to do
                            something about the situation and implement a
                            unified, consistent messaging system. The result is
                            a publisher-subscriber system:</p>
                        <ul>
                            <li>Publishers register MessageIDs.</li>
                            <li>Anyone can subscribe to these MessageIDs by
                                registering callbacks. Several subscribers are
                                possible in all cases.
                            </li>
                            <li>When an event occurs, all registered callbacks
                                are invoked.
                            </li>
                        </ul>
                        <p>We spent quite a bit of time to make a lot of things
                            &#8220;just work&#8221;. The subscription interface
                            is very simple. As an example, this is how you
                            register for a mouse or touch down event:</p>
                        <pre>node.subscribe(node.CURSOR_DOWN, self.onDown)</pre>
                        <p>Any Python callable can be registered as a callback,
                            including standalone functions, class methods,
                            lambdas and even class constructors. In most cases,
                            you don&#8217;t have to deregister messages to clean
                            up either. Subscriptions are based on weak
                            references wherever possible, so when the object
                            they refer to disappears, the subscription will just
                            disappear as well.</p>
                        <p>You can write your own publishers can be written in
                            Python or C++ by simply deriving from the Publisher
                            class. In Python, you need two lines of code to
                            register a message:</p>
                        <pre>class Button(avg.DivNode):
 CLICKED = avg.Publisher.genMessageID()
    [...]
    def __init__(...):
        self.publish(self.CLICKED)
    [...]</pre>
                        <p>and this line invokes all registered subscribers:</p>
                        <pre>self.notifySubscribers(self.CLICKED, [])</pre>
                        <p>The second parameter to
                            <code>notifySubscribers</code> is a list of
                            parameters to pass to the subscribers.</p>
                        <h1>Transitioning</h1>
                        <p>Transitioning old programs to the new interface is
                            not very hard and involves replacing old calls to
                            <code>Node.connectEventHandler()</code>, <code>VideoNode.setEOFCallback()</code>,
                            <code>Contact.connectListener()</code> and so on
                            with invocations of <code>subscribe()</code>. We&#8217;ll
                            keep the old interfaces around for a while, but they&#8217;ll
                            probably be removed when we release ver 2.0.</p>
                    </div><!-- .entry-content -->

                </article><!-- #post-43 -->


                <article id="post-39"
                         class="post-39 post type-post status-publish format-standard hentry category-input">
                    <header class="entry-header">
                        <h1 class="entry-title">The End of Touch Jitter</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2012-08-18T12:31:35+00:00">August
                                18, 2012
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="../../author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>On lots of multitouch devices, input suffers from
                            <em>jitter</em>: The actual touch location is
                            reported imprecisely and changes from frame to
                            frame. This has obvious negative effects, since it&#8217;s
                            much harder to hit a target this way. For years,
                            people have been telling me that a lowpass filter
                            would help. In its simplest form, a lowpass filter
                            averages together the location values from the last
                            few frames. This removes most of the jitter &#8211;
                            because the jitter is random, there&#8217;s a good
                            chance that the errors in successive frames cancel
                            each other out. On the other hand, it adds latency
                            because the software is not using the latest data.
                            This tradeoff didn&#8217;t seem like a good one to
                            me, so I didn&#8217;t add a jitter filter to libavg.
                        </p>
                        <p>However, at this year&#8217;s CHI conference, Gry
                            Casiez and coauthors published a paper on a <a
                                    title="1 filter"
                                    href="http://www.lifl.fr/~casiez/1euro/"
                                    target="_blank">1 Filter</a>. This filter
                            is based on an extremely simple observation: Precise
                            positions are only important when the user is moving
                            his finger slowly, while latency is important at
                            fast speeds. So, the solution to the dilemma I
                            described in the first paragraph is to build a
                            filter that adjusts its latency depending on speed.
                            Their filter is extremly simple to implement, and
                            the results are really nice.</p>
                        <p>libavg can now process the touch input positions
                            using this filter. The filter parameters are
                            configurable in avgrc, and there&#8217;s a
                            configuration utility
                            (<code>avg_jitterfilter.py</code>) that helps in
                            finding correct filter values. The complete
                            implementation is in the <code>libavg_uilib</code>
                            branch &#8211; I&#8217;ll merge it to trunk in the
                            next few weeks.</p>
                    </div><!-- .entry-content -->

                </article><!-- #post-39 -->


                <article id="post-32"
                         class="post-32 post type-post status-publish format-standard hentry category-application">
                    <header class="entry-header">
                        <h1 class="entry-title">Talk On SimMed</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2012-07-11T22:56:10+00:00">July 11,
                                2012
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="../../author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>In April, I gave a talk on <a
                                href="../../../site/projects/libavg/wiki/SimMed.html"
                                title="SimMed" target="_blank">SimMed</a>, our
                            multitouch medical education project (using libavg).
                            The people at the Saarbrcken Centre for e-Learning
                            Technology have put a video of the talk online. I
                            believe it shows very well what we&#8217;re trying
                            to do (sorry it&#8217;s in German):</p>
                        <p>
                            <iframe width="584" height="329"
                                    src="https://www.youtube.com/embed/_u89LyQ9zhc?feature=oembed"
                                    frameborder="0" allowfullscreen></iframe>
                        </p>
                    </div><!-- .entry-content -->

                </article><!-- #post-32 -->


                <article id="post-26"
                         class="post-26 post type-post status-publish format-standard hentry category-optimization category-rendering">
                    <header class="entry-header">
                        <h1 class="entry-title">Intel Graphics</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span>
                            <time class="entry-date"
                                  datetime="2012-06-10T23:50:26+00:00">June 10,
                                2012
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="../../author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>After the rendering optimization I desribed in my
                            last post, tests with Intel Atom chipset graphics
                            (N10 chipset) uncovered a problem. The system was
                            running in software rendering mode, which slows
                            things down by a factor of about a thousand. It
                            turns out that more than two texture accesses in a
                            shader are too much for the hardware. Additionally,
                            lots of Intel chips render all vertex shaders in
                            software, and that also causes a tenfold slowdown if
                            the libavg 3-line vertex shader is in use.</p>
                        <p>So now, there&#8217;s a second rendering path with
                            minimal shaders that does vertex processing the
                            old-fashioned way (<code>glMatrixMode</code> etc.)
                            and uses a different shader for those nodes that don&#8217;t
                            need any special processing. Still, I recommend
                            staying away from Intel Atom graphics. There is way
                            better hardware out there at the same price point.
                        </p>
                    </div><!-- .entry-content -->

                </article><!-- #post-26 -->


                <article id="post-1"
                         class="post-1 post type-post status-publish format-standard hentry category-optimization category-rendering">
                    <header class="entry-header">
                        <h1 class="entry-title">Speeding up Rendering</h1>

                        <div class="entry-meta">
                            <span class="sep">Posted on </span
                            <time class="entry-date"
                                  datetime="2012-05-25T09:51:54+00:00">May 25,
                                2012
                            </time>
                        <span class="by-author"> <span
                                class="sep"> by </span> <span
                                class="author vcard"><a class="url fn n"
                                                        href="../../author/uzadow/index.html"
                                                        title="View all posts by Ulrich von Zadow"
                                                        rel="author">Ulrich von Zadow</a></span></span>
                        </div><!-- .entry-meta -->

                    </header><!-- .entry-header -->

                    <div class="entry-content">
                        <p>libavg&#8217;s rendering has been fast enough for
                            many applications for a while. A decent desktop
                            computer could render between 2000 and 5000 nodes
                            with a framerate of 60 in version 1.7. This is
                            probably already more than most frameworks, but for
                            big applications, it&#8217;s not enough. For
                            instance, someone tried to build a game of life
                            application with one node per grid point &#8211; and
                            ran into performance issues. <a
                                    href="http://www.archimedes-exhibitions.de/exhibits/medicine_technology/_/simmed.html">SimMed</a>
                            spends an inordinate amout of time rendering 2D as
                            well. Also, particle animations and similar effects
                            need lots of nodes.</p>
                        <p>So, I went and optimized the rendering pipeline. As a
                            bonus, I was able to remove lots of deprecated
                            OpenGL function usage, thus getting us a lot closer
                            to mobile device support.</p>
                        <p><strong>tl;dr</strong>: On a desktop system with a
                            good graphics card, the benchmarks now show libavg
                            rendering two or three times as many nodes as
                            before.</p>
                        <h1>The new rendering pipeline</h1>
                        <p>One mantra that&#8217;s often repeated when
                            optimizing graphics pipelines is <em>&#8220;minimize
                                state changes&#8221;</em> (See Tom Forsyths blog
                            entry on <a
                                    href="http://home.comcast.net/~tom_forsyth/blog.wiki.html#Renderstate%20change%20costs"
                                    target="_blank">Renderstate change costs</a>
                            and
                            <a href="http://developer.nvidia.com/docs/IO/8230/BatchBatchBatch.pdf"
                               target="_blank">NVidias GDC talk slides</a>). <a
                                    href="http://pavelmayer.de/"
                                    target="_blank">Pavel Mayer</a> once
                            (over-)simplified this to <em>&#8220;minimize the
                                number of GL calls&#8221;</em>, and my
                            experience has been that that&#8217;s actually a
                            very good starting point.</p>
                        <p>Today&#8217;s graphics cards are optimized for large,
                            complex 3D models with comparatively few textures.
                            2D applications rendered using 3D graphics cards
                            render lots of small primitives &#8211; mostly
                            rectangles &#8211; with different textures. A naive
                            implementation uses one vertex buffer per primitive.
                            That results in a huge number of state changes and
                            is about the worst way to use current graphics
                            cards.</p>
                        <p>The new rendering pipeline makes the most of the
                            situation by:</p>
                        <ul>
                            <li>Putting all vertex coordinates into one big
                                vertex buffer. This vertex buffer is uploaded
                                once per frame, activated and used for all
                                rendering. The one big upload takes less time
                                than actually figuring out what needs to be
                                uploaded and doing the work piecewise.
                            </li>
                            <li>Using one <a
                                    href="../../../site/login20d0.html">standard
                                shade</a>r for all nodes. This shader handles
                                color space transforms,
                                brightness/contrast/gamma and masks, meaning it
                                does a lot more work than is necessary for most
                                nodes. However, the shader never changes during
                                the main rendering pass. It turns out that the
                                increased per-pixel processing is no problem for
                                all but the slowest GPUs, while the state
                                changes that would otherwise be needed cost
                                signficant time on the CPU side.
                            </li>
                            <li>FX nodes are rendered to textures in a prerender
                                pass with their own shaders.
                            </li>
                            <li>Generally moving GL state changes outside of the
                                render loop if possible and substituting shader
                                parameters for old-style GL state.
                            </li>
                            <li>Caching all other GL state changes. There are
                                just a few GL state variables that still change
                                during rendering (To be precise: <code>glBlendColor</code>,
                                the active blend function, and parameters to the
                                standard shader). Now, setting a shader
                                parameter to the same value repeatedly doesn&#8217;t
                                cause several GL calls.
                            </li>
                        </ul>
                        <p>There were also a few non-graphics related
                            optimizations &#8211; profiling information is now
                            only collected if profiling is turned on, for
                            example.</p>
                        <h1>Results</h1>
                        <p>Without further ado, here are some benchmarks using
                            <code>avg_checkspeed</code> and <code>avg_checkpolygonspeed</code>.
                            They show nodes per Frame at 60 FPS on a typical
                            desktop system (Core i7 920 Bloomfield, 2.66 MHz,
                            NVidia GF260):</p>
                        <h3>Desktop, Linux (Ubuntu 12.04, Kernel 3.2)</h3>
                        <table cellspacing="0">
                            <tr>
                                <th>libavg Version</th>
                                <th>Images</th>
                                <th>Polygons</th>
                            </tr>
                            <tr>
                                <td>1.7</td>
                                <td>2200</td>
                                <td>3500</td>
                            </tr>
                            <tr>
                                <td>Current</td>
                                <td>7000</td>
                                <td>7000</td>
                            </tr>
                        </table>
                        <h3>Desktop, Win 7</h3>
                        <table cellspacing="0">
                            <tr>
                                <th>libavg Version</th>
                                <th>Images</th>
                                <th>Polygons</th>
                            </tr>
                            <tr>
                                <td>1.7</td>
                                <td>&nbsp;&nbsp;2700</td>
                                <td>5000</td>
                            </tr>
                            <tr>
                                <td>Current</td>
                                <td>10000</td>
                                <td>9500</td>
                            </tr>
                        </table>
                        <p>On my MacBook Pro (Mid-2010, Core i7 Penryn, 2.66
                            MHz, NVidia GF330M graphics, Snow Leopard), the
                            maximum number of nodes rendered did not increase.
                            However, the CPU load while rendering went down
                            &#8211; so we have a GPU bottleneck here:</p>
                        <h3>MacBook Pro</h3>
                        <table cellspacing="0">
                            <tr>
                                <th>libavg Version</th>
                                <th>Images</th>
                                <th>Polygons</th>
                            </tr>
                            <tr>
                                <td>1.7</td>
                                <td>1000, 100% CPU load</td>
                                <td>1600, 100% CPU load</td>
                            </tr>
                            <tr>
                                <td>Current</td>
                                <td>1000, 80% CPU load</td>
                                <td>1600, 40% CPU load</td>
                            </tr>
                        </table>
                        <p>More precisely, since changing multisampling settings
                            has an effect on speed, fragment processing is the
                            bottleneck. Changing to minimal shaders doesn&#8217;t
                            have an effect on speed either, so I&#8217;m
                            guessing at texture fetches at the moment. But that&#8217;s
                            for the next iteration of optimizations.</p>
                    </div><!-- .entry-content -->

                </article><!-- #post-1 -->


            </div><!-- #content -->
        </div><!-- #primary -->

        <div id="secondary" class="widget-area" role="complementary">
            <aside id="text-2" class="widget widget_text">
                <div class="textwidget">This is a blog about the development of
                    the media and interaction framework libavg.

                </div>
            </aside>
        </div><!-- #secondary .widget-area -->

    </div><!-- #main -->

    <footer id="colophon" role="contentinfo">


    </footer><!-- #colophon -->
</div><!-- #page -->


</body>

<!-- Mirrored from www.libavg.de/blog/ by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 11 Jan 2025 18:15:16 GMT -->
</html>